Гистограмма частот для непрерывной переменной

Eсли мы не можем посчитать частоту для значений разной точности, можно разбить всю шкалу на интервалы и найти число значений в каждом.
Количество таких интервалов, или корзин, вы задавали в параметре bins. Можно указывать не число корзин, а границы самих интервалов — их передают списком:
import pandas as pd

data = pd.Series([11, 20, 22, 31, 32, 33, 41, 42, 43, 44, 51, 52, 53, 54, 55, 61, 62, 63, 64, 65, 66, 71, 72, 73, 74, 75, 76, 77, 81, 82, 83, 84, 85, 86, 87, 88, 91, 92, 93, 94, 95, 96, 97, 98, 99])

data.hist(bins=4, alpha=0.5)  # строим гистограмму с 4 корзинами

data.hist(
    bins=[11, 20, 30, 40, 50, 60, 70, 80, 90, 99], alpha=0.7
)  # строим гистограмму с 9 корзинами, границы которых перечислены в списке


1. Вы обновили интерфейс страницы оформления покупки на сайте и хотите понять, насколько сложно пользователям даётся этот процесс. Изучите самую простую метрику — время оформления покупки.
За первый день с новым интерфейсом вы получили достаточно измерений, чтобы построить гистограмму.
В прекоде набор данных со временем оформления покупки (в секундах). Постройте гистограмму с границами корзин в точках [15, 30, 45, 60, 75, 90]. Задайте непрозрачность, равную 0.7.

import pandas as pd

# датасет pur_time от англ. purchase time, «время покупки»
pur_time = pd.Series([36, 44, 73, 32, 44, 29, 63, 60, 55, 74, 61, 26, 76, 40, 39, 28, 69, 61, 54, 58, 47, 41, 70, 51, 58, 36, 71, 47, 74, 59, 50, 78, 59, 48, 67, 53, 67, 52, 38, 55, 53, 53, 43, 77, 44, 63, 63, 54])
pur_time.hist(
    bins=[15, 30, 45, 60, 75, 90], alpha=0.7)


2. Постройте две гистограммы времени оформления покупки со следующими границами интервалов:
[15, 35, 55, 75, 90]
[15, 45, 55, 90]
Для обеих гистограмм задайте прозрачность, равную 0.5.

import pandas as pd

# назовем датасет pur_time от англ. purchase time, «время покупки»
pur_time = pd.Series([36, 44, 73, 32, 44, 29, 63, 60, 55, 74, 61, 26, 76, 40, 39, 28, 69, 61, 54, 58, 47, 41, 70, 51, 58, 36, 71, 47, 74, 59, 50, 78, 59, 48, 67, 53, 67, 52, 38, 55, 53, 53, 43, 77, 44, 63, 63, 54])

pur_time.hist(
    bins=[15, 35, 55, 75, 90], alpha=0.5)

pur_time.hist(
    bins=[15, 45, 55, 90], alpha=0.5)


Гистограммы плотностей    

Вы убедились, что частотная гистограмма плохо подходит непрерывным переменным: частота попадания значений в интервалы зависит от выбора границ интервалов. Нужен особый способ: учитывающий как интервалы, так и частоту попадания значений. Что если отображать частоту не высотой столбца, а его площадью?
Площадь такого столбца находят, как площадь прямоугольника: длину интервала умножают на высоту столбца. Найденная площадь — частота непрерывной переменной, а высота столбца — плотность частоты.

Как рассчитать плотность частоты попадания значений в интервал?
*поделить частоту интервала на его ширину
Площадь прямоугольника — высота, помноженная на ширину. Значит, высота — это площадь, делённая на ширину.

Гистограмма, построенная таким образом, называется плотностная гистограмма.

Плотность частоты для непрерывных переменных можно задавать не только прямоугольниками, как на гистограммах, но и кривыми функциями. Работает тот же принцип: площадь между двумя значениями пропорциональна частоте попадания значений в интервал между ними.
Например, на графике нормального распределения видно, что бóльшая часть значений находится между пунктирными линиями:

Как и в случае с плотностной гистограммой, значения лежат на горизонтальной оси, а площадь графика задаёт частоту появления значений в заданном интервале.
Эта идея — соответствие площади графика над интервалом значений частоте попадания в этот интервал — пригодится вам при статистической проверке гипотез.

Кто разбросал данные?
Найдите среднее в наборе данных и посчитайте среднее расстояние до него от всех значений. Полученное значение spacing_all_mean выведите на экран.

import pandas as pd

data = pd.Series([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
mean_value =  data.mean()
spacing_all = data - mean_value
spacing_all_mean = spacing_all.mean()
print(spacing_all_mean)

Стандартное отклонение


1. Оцените дисперсию генеральной совокупности data = pd.Series([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]). Результат выведите на экран.
import pandas as pd
import numpy as np

data = pd.Series([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
variance = np.var(data)
print(variance) 

2. Оцените дисперсию по выборке data = pd.Series([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]). Результат выведите на экран.

import pandas as pd
import numpy as np

data = pd.Series([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
variance_estimate = np.var(data,ddof=1)
print(variance_estimate)

3. Оцените стандартное отклонение по выборке data = pd.Series([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]). Сохраните результат в переменной standard_dev и выведите её на экран.

import pandas as pd
import numpy as np

data = pd.Series([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

standard_dev = np.std(data,ddof=1)
print(standard_dev)

4. В среднем пользователи разглядывают всплывающие сообщения на сайте 3 секунды. Дисперсия равна 0,25 секунд в квадрате. По правилу трёх сигм рассчитайте, сколько времени нужно показывать сообщение, чтобы его успело разглядеть 99% пользователей.
Результат на экран выведите так: Время показа сообщения ... .
import numpy as np

adv_mean = 3
adv_var = 0.25
adv_std = np.sqrt(adv_var)
adv_time = adv_mean + adv_std * 3
print('Время показа сообщения',adv_time)

Закон больших чисел
Задача. Яндекс отслеживает количество удачных постов определённого блога для Дзена. 
Абсолютно удачным постом считается такой, у которого число репостов сравнимо с числом лайков. Этот успех считаем за 100%.
Сгенерируйте 20, 400, 10000 случайных целых чисел из отрезка [1, 100].
Это соотношение репостов к лайкам в популяции блогеров в целом. 
Если для избранного блогера соотношение всегда выше, он причисляется к хорошим.
Для каждого набора чисел вычислите вероятность события «Сгенерированное число лежит в отрезке [21, 40]» (самая типичная доля репостов).
Сохраните её в переменных p_20, p_400 и p_10000 соответственно.
Для вычисления вероятности напишите функцию calculate_p 
которая принимает в качестве параметра количество случайных чисел из отрезка [1, 100], а на выходе передаёт долю тех чисел,
которые находятся в отрезке от 21 до 40 включительно.
Выведите полученные вероятности на экран на одной строке.


import random

random.seed(1111)  # метод seed() задаёт степень случайности, не меняйте её


def calculate_p(N):
    cnt_21_40 = 0
    for i in range(N):
        random_integer =  random.randint(1, 100)
        if random_integer >= 21 and random_integer <= 40:
            cnt_21_40 += 1        
    return cnt_21_40/N


p_20 = calculate_p(20)
p_400 = calculate_p(400)
p_10000 = calculate_p(10000)
print(p_20, p_400, p_10000)

Случайные величины, распределение вероятностей и интервалы значений


1. В переменной spot_matrix хранится матрица с вероятностным пространством «сумма количества пятен двух питонов, 
у которых с равной вероятностью могут появиться от 5 до 10 пятен».
Составьте словарь spot_probs с распределением вероятностей для этой случайной величины. 
Ключами в словаре должны быть целые числа — возможные исходы эксперимента (тип int), значениями — вероятности исходов типа float. 
Выведите значение переменной spot_probs на экран.

import numpy as np

spot_matrix = np.array(
    [
        [10, 11, 12, 13, 14, 15],
        [11, 12, 13, 14, 15, 16],
        [12, 13, 14, 15, 16, 17],
        [13, 14, 15, 16, 17, 18],
        [14, 15, 16, 17, 18, 19],
        [15, 16, 17, 18, 19, 20],
    ]
)

spot_counts   = {}

for i in range(0, 6):
        for j in range(0, 6):
                if spot_matrix[i][j] not in spot_counts.keys():
                        spot_counts[spot_matrix[i][j]] = 1
                else:
                        spot_counts[spot_matrix[i][j]] += 1

spot_probs = {k:spot_counts[k]/36 for k in spot_counts} 

print(spot_probs)

2. Проверьте, что сумма вероятностей всех возможных исходов равна единице.
Запишите результат в переменную sum_probs_one и выведите на экран.
Не удаляйте вывод spot_probs из предыдущего задания.

import numpy as np

spot_matrix = np.array(
    [
        [10, 11, 12, 13, 14, 15],
        [11, 12, 13, 14, 15, 16],
        [12, 13, 14, 15, 16, 17],
        [13, 14, 15, 16, 17, 18],
        [14, 15, 16, 17, 18, 19],
        [15, 16, 17, 18, 19, 20],
    ]
)

spot_counts   = {}

for i in range(0, 6):
        for j in range(0, 6):
                if spot_matrix[i][j] not in spot_counts.keys():
                        spot_counts[spot_matrix[i][j]] = 1
                else:
                        spot_counts[spot_matrix[i][j]] += 1

spot_probs = {k:spot_counts[k]/36 for k in spot_counts} 

print(spot_probs)
sum_probs_one = round(sum(spot_probs.values()))
print(sum_probs_one)

Математическое ожидание и дисперсия
1. В переменной x_probs в виде словаря задано распределение вероятностей случайной величины X — апрельской температуры в городе N. 
Найдите её математическое ожидание и дисперсию. 
Сохраните результаты в переменных expectation(англ. «ожидание») и variance (англ. «разброс»). Выведите их на экран.

import numpy as np

x_probs = {
    '-4': 0.05,
    '-2': 0.25,
    '0': 0.1,
    '1': 0.1,
    '5': 0.1,
    '7': 0.05,
    '15': 0.35,
}
expectation  = sum(int(i)*x_probs[i] for i in x_probs)
variance = sum((int(i)**2)*x_probs[i] for i in x_probs) - expectation**2
print('Математическое ожидание равно', expectation)
print('Дисперсия равна', variance)

2. Известно, что питоны разных знаков Зодиака дорастают до различного взрослого веса. 
Водные знаки весят 2 кг, Огненные и Земляные — 3 кг, Воздушные — 5 кг. 
Питоны рождаются с одинаковой частотой на протяжении всего года.
Запишите в словарь weight_probs распределение вероятностей для случайной величины «Вес питона». 
В качестве ключей словаря используйте строковые значения, а не числовые. 
Найдите математическое ожидание и дисперсию случайной величины, запишите их в переменные expectation и variance. 
Результат выведите на экран.

import numpy as np


weight_probs = {
    '2' : 0.25,
    '3' : 0.5,
    '5' : 0.25
}
# Вероятность того, что отдельно взятый питон окажется одним из 12 знаков Зодиака, равна 1/12.
# Вероятность того, что он принадлежит к одной из 4 стихий, равна 1/4.
# Вероятности для двух стихий - Огня и Земли - нужно сложить, чтобы получить вероятность
# того, что питон весит 3 кг, для остальных просто остается 1/4.

# здесь код создания словаря и расчётов
expectation = sum(int(i)*weight_probs[i] for i in weight_probs)
variance = sum((int(i)**2)*weight_probs[i] for i in weight_probs) - expectation**2
print('Математическое ожидание равно', expectation)
print('Дисперсия равна', variance)

Вероятность успеха в биномиальном эксперименте



_____________________________________________________________
Нормальное распределение

1. Количество посетителей сайта интернет-издания «Кукуруза» за месяц
распределено нормально со средним, равным 100500 человек, и стандартным отклонением в 3500 человек.
Рекламодатель, заказавший рекламу, настоял на штрафе, если материал посмотрит меньше 92000 посетителей. 
Его желание понятно: никто не хочет переплачивать, если охват будет не такой большой, как хотелось. 
В ответ менеджер сайта предложил включить в договор бонус, если материал посмотрит более 111000 человек.
Предположим, что дополнительных действий по привлечению трафика запланировано не было. 

Найдите вероятность того, что сайт интернет-издания за следующую неделю посетит: а) менее 92000 человек; б) более 111000 человек.

from scipy import stats as st

mu = 100500 # вставьте ваш код здесь: чему равно среднее значение распределения
sigma = 3500 # вставьте ваш код здесь: чему равно стандартное отклонение распределения
distr=st.norm(100500, 3500)
bonus_threshold = 111000 # вставьте ваш код здесь: где проходит граница для бонуса
penalty_threshold = 92000 # вставьте ваш код здесь: где проходит граница для штрафа

p_bonus = 1 -  distr.cdf(bonus_threshold) # вставьте ваш код здесь: посчитайте вероятность получить бонус
p_penalty = distr.cdf(penalty_threshold)# вставьте ваш код здесь: посчитайте вероятность получить штраф

print('Вероятность бонуса:', p_bonus)
print('Вероятность штрафа:', p_penalty)


Метод st.norm.cdf() выдаёт вероятность получить значение, которое меньше или равно заданному. 
Нормальное распределение — это распределение вероятности, а его общая площадь равна единице.
Значит, чтобы получить значение больше или равное заданному, нужно вычесть из единицы результат функции st.norm.cdf()

2. Интернет-магазин «Супервип» продаёт сувенирную продукцию для узкой аудитории корпоративных клиентов. 
Продажи премиальных шахмат из хрусталя за неделю распределены нормально со средним значением 420 и стандартным отклонением 65.
Сколько отделу закупок нужно заказать хрустальных шахмат, чтобы продать их все на следующей неделе с вероятностью 90%? 
Склад перед поставкой на следующую неделю будет уже пуст.

Чтобы посчитать количество единиц товара, вызовите функцию st.norm.ppf().
Значение, ниже которого лежат 10% значений, симметрично относительно средней величины значения, ниже которого — 90% значений. 
Функция ppf выдаёт значение для аргумента «вероятность попасть в это значение или меньше». 
Поэтому передайте методу не саму вероятность, с которой нужно распродать весь товар (переменная prob), а величину 1-prob.

from scipy import stats as st

mu = 420 # вставьте ваш код здесь: чему равно среднее значение распределения
sigma = 65 # вставьте ваш код здесь: чему равно стандартное отклонение распределения
distr=st.norm(mu,sigma)
prob = 0.9 # вставьте ваш код здесь: с какой вероятностью нужно распродать весь товар?

n_shipment = distr.ppf(1-prob)
print('Нужно заказать единиц товара:', int(n_shipment))


3. В интернет-магазине «Вазон» пользователи делают заказы, стоимости которых распределены нормально со средним 2400 руб. 
и стандартным отклонением 320 руб.
Бóльшая часть покупателей выбирает доставку курьером, на которую нужно установить фиксированную цену независимо от суммы заказа.
Если верить исследованию, пользователи расстраиваются, когда стоимость доставки больше или равна половине стоимости заказа. 
Сколько должна стоить курьерская доставка, чтобы для ³⁄₄ заказов она не превышала половины цены?

Нужно найти первый квартиль распределения: сумму заказа, дешевле которой ¹⁄₄ всех заказов, а дороже — ³⁄₄ всех заказов.
Не забудьте поделить результат пополам, ведь доставка должна быть не дороже половины цены.

from scipy import stats as st

mu = 2400 # вставьте ваш код здесь: чему равно среднее значение распределения
sigma = 320 # вставьте ваш код здесь: чему равно стандартное отклонение распределения
threshold = 0.75 # вставьте ваш код здесь: какая доля заказов должна быть дороже двух стоимостей доставки?
distr = st.norm(mu, sigma)
max_delivery_price = distr.ppf(1-threshold)/2# вставьте ваш код здесь: какую стоимость доставки установить?

print('Максимальная стоимость доставки курьером:', max_delivery_price)


Нормальная аппроксимация биномиального распределения
Задача. Компания делает ежемесячную рассылку по базе клиентов — в ней новости и предложения от партнёров.
Известно, что рассылку открывают 40% получателей.
Один партнёр спланировал рекламную кампанию и рассчитывает на охват в 9 тысяч пользователей.
Посчитайте, с какой вероятностью ожидания клиента будут оправданы, если сделать рассылку на 23 тысячи человек. 
Выведите значение p_threshold на экран.

Функция st.norm.cdf() выдаёт вероятность получить значение, меньше и равное заданному. 
Следовательно, так как нормальное распределение — это распределение вероятности, 
и общая площадь под кривой плотности его распределения равна единице, 
для получения значения больше или равному заданного, нужно использовать единицу минус результат функции st.norm.cdf()

from scipy import stats as st
import math as mt

binom_n = 23000# ваш код здесь - целевое количество человек в рассылке
binom_p = 0.4 # ваш код здесь - сколько пользователей открывают рассылку?

threshold = 9000# ваш код здесь - на какой охват сейчас рассчитывают?

mu =  binom_n * binom_p 
# ваш код здесь: чему равно среднее значение распределения
sigma = mt.sqrt(binom_n * binom_p * (1 - binom_p))
# ваш код здесь: чему равно стандартное отклонение распределения

p_threshold = 1 - st.norm(mu,sigma).cdf(threshold)# ваш код здесь
print(p_threshold)
# чеез cdf мы считаем вероятность что мы пересечум нужный кусок распределения, соответсвенно чтобы найти вероятность успеха
# мы считаем 1 - эту вероятность.
